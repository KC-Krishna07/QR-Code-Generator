ğŸ”· PROJECT OVERVIEW
Project Name

QR Code Generator Web Application

What the Project Does

Takes text / URL as input

Generates a QR code

Ensures same input always produces the same QR

Stores generated QR codes locally

Avoids regenerating QR for repeated inputs

Allows QR download

Uses modern UI design (glassmorphism + animation)

ğŸ”· TECH STACK (WHY EACH IS USED)
Technology	Purpose
HTML5	Page structure
CSS3	Layout, animations, glass UI
JavaScript	Logic, storage, QR generation
QRCode.js	QR encoding algorithm
LocalStorage	Client-side database
ğŸ”· COMPLETE SYSTEM FLOW (BIG PICTURE)
User Input
   â†“
Check Local Database
   â†“
Exists? â”€â”€ YES â”€â”€> Fetch Stored QR
   â†“ NO
Generate New QR
   â†“
Store in Database
   â†“
Display + Download


This is exactly how real systems avoid duplication.

ğŸ”· HTML â€“ STRUCTURE EXPLAINED
1ï¸âƒ£ <head> Section
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

Why this matters

This library:

Converts text â†’ binary data

Applies QR encoding rules

Draws QR using <canvas> or <img>

We donâ€™t implement QR algorithm ourselves (industry practice)

2ï¸âƒ£ Floating Shapes
<div class="shapes">
    <span></span>
    <span></span>
    <span></span>
</div>

Purpose

Purely decorative

Adds depth & motion

No business logic

3ï¸âƒ£ Main Container
<div class="container">


This acts as:

UI card

Visual focus area

Holds all interactive components

4ï¸âƒ£ Input Field
<input type="text" id="qrText">

Key Concept

id="qrText" lets JavaScript directly access user input

Accepts:

URLs

Text

Numbers

Any string

5ï¸âƒ£ Button
<button onclick="generateQR()">Generate QR</button>

How it works

Inline event handler

Calls generateQR() function in JavaScript

6ï¸âƒ£ QR Display Area
<div id="qrBox"></div>


Empty initially

QR image is inserted dynamically

This is where QR is rendered

7ï¸âƒ£ Download Link
<a id="downloadBtn" download="qrcode.png">Download QR</a>

Key Detail

download attribute forces file download

href is set dynamically using QR image source

ğŸ”· CSS â€“ VISUAL ENGINEERING EXPLAINED
1ï¸âƒ£ Global Reset
* {
    box-sizing: border-box;
}

Why important

Ensures padding doesnâ€™t break layouts

Industry best practice

2ï¸âƒ£ Animated Gradient Background
background-size: 300% 300%;
animation: gradientMove 12s ease infinite;

Concept

Large gradient surface

Shift background position over time

Creates illusion of motion

3ï¸âƒ£ Glassmorphism Card
background: rgba(255,255,255,0.18);
backdrop-filter: blur(15px);

Whatâ€™s happening

Semi-transparent background

Background behind card is blurred

Mimics frosted glass

4ï¸âƒ£ Floating Shapes
@keyframes float {
    transform: translateY(-30px);
}

Purpose

Adds depth

Makes UI feel alive

No impact on performance

5ï¸âƒ£ QR Centering
display: flex;
justify-content: center;
align-items: center;

Why flexbox

Reliable centering

Responsive

Cleaner than margins

ğŸ”· JAVASCRIPT â€“ CORE LOGIC (MOST IMPORTANT)
1ï¸âƒ£ Accessing DOM Elements
let qrBox = document.getElementById("qrBox");

DOM = Document Object Model

JavaScript controls HTML elements via DOM references.

2ï¸âƒ£ LocalStorage as Database
let qrDatabase = JSON.parse(localStorage.getItem("qrDatabase")) || {};

VERY IMPORTANT CONCEPT

localStorage stores key-value pairs

Data persists even after refresh

Stored as strings

Example Stored Data
{
  "send": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUg..."
}


âœ” Key â†’ User input
âœ” Value â†’ QR image encoded as Base64

3ï¸âƒ£ Why Base64?

QRCode.js generates image

Image is converted to Base64 string

Base64:

Can be stored as text

Can be reused as image source

Can be downloaded

4ï¸âƒ£ Preventing QR Repetition (CORE LOGIC)
if (qrDatabase[text]) {

What this means

Check if input already exists

If yes:

Load existing QR

If no:

Generate new QR

Store it

ğŸ“Œ This is exactly how caching works in backend systems

5ï¸âƒ£ QR Generation
new QRCode(qrBox, {
    text: text,
    width: 200,
    height: 200
});

What happens internally

Text â†’ Binary encoding

Error correction bits added

Matrix generated

QR image rendered

6ï¸âƒ£ Why setTimeout()?
setTimeout(() => {

Reason

QR image generation is asynchronous

DOM needs time to render <img>

We wait before reading img.src

7ï¸âƒ£ Download Logic
downloadBtn.href = img.src;

Result

Clicking link downloads QR

No backend needed

Uses browser-native behavior

ğŸ”· HOW DATABASE LOGIC SCALES (INDUSTRY)
Current (Client-side)
Feature	Status
Persistence	Yes
Duplication prevention	Yes
Offline	Yes
Multi-user	No
Real Backend Version
Component	Example
Backend	Node.js
API	/generate-qr
DB	MongoDB
Logic	Check â†’ generate â†’ store
{
  "input": "send",
  "qrHash": "abc123",
  "qrData": "base64..."
}

ğŸ”· WHY THIS PROJECT IS STRONG

âœ” Shows frontend engineering
âœ” Demonstrates data caching
âœ” UI + logic combined
âœ” Industry-relevant patterns
âœ” Perfect for resume & interviews







ğŸ”· WHAT A QR CODE REALLY IS (FIRST PRINCIPLE)

A QR code is NOT an image first.
It is:

A 2D binary data matrix that follows strict international encoding rules (ISO/IEC 18004)

Only after data is encoded into that matrix does it become an image.

ğŸ”· HIGH-LEVEL PIPELINE (REAL PROCESS)

When you enter:

send


This happens internally:

Text
 â†“
Character Encoding
 â†“
Binary Conversion
 â†“
Error Correction
 â†“
QR Matrix Construction
 â†“
Masking
 â†“
Rendered as Image


Letâ€™s break every single step.

ğŸ”· STEP 1: INPUT DATA

Example input:

send


This is plain text.

The QR library first answers:

What type of data is this?

Possible QR data types:

Numeric

Alphanumeric

Byte (UTF-8)

Kanji

Your input "send" is Alphanumeric mode.

ğŸ”· STEP 2: MODE INDICATOR (CRITICAL)

QR codes always start with mode bits.

Mode	Binary
Numeric	0001
Alphanumeric	0010
Byte	0100

For "send" â†’ Alphanumeric:

0010


This tells scanners how to decode the data later.

ğŸ”· STEP 3: CHARACTER COUNT INDICATOR

QR must tell:

â€œHow many characters are coming?â€

send â†’ 4 characters


For small QR versions:

4 â†’ 000100


So now we have:

0010 000100

ğŸ”· STEP 4: DATA ENCODING (VERY IMPORTANT)

Each character in Alphanumeric mode has a fixed value:

Character	Value
S	28
E	14
N	23
D	13

QR groups characters in pairs:

(S, E) â†’ 28 Ã— 45 + 14 = 1274
(N, D) â†’ 23 Ã— 45 + 13 = 1048


Converted to binary:

1274 â†’ 10011111010
1048 â†’ 10000011000


Now data looks like:

0010 000100 10011111010 10000011000

ğŸ”· STEP 5: TERMINATOR & PADDING

QR codes must fill exact capacity.

So the library:

Adds terminator bits (0000)

Adds padding bits (11101100, 00010001)

Ensures correct total length

ğŸ“Œ This guarantees:

Scanner reliability

Fixed structure

ğŸ”· STEP 6: ERROR CORRECTION (THIS IS WHY QR WORKS DAMAGED)

QR uses Reedâ€“Solomon Error Correction.

What this does:

Adds extra recovery data

Allows QR to be readable even if ~30% is damaged

Error correction levels:

L (7%)

M (15%)

Q (25%)

H (30%)

QRCode.js usually uses Level M by default.

ğŸ“Œ This is real mathematics, not styling.

ğŸ”· STEP 7: BUILDING THE QR MATRIX (THE GRID)

Now we convert binary data into a square grid:

Black = 1

White = 0

Matrix contains:

Finder patterns (big squares)

Alignment patterns

Timing patterns

Data modules

This is why QR always looks the same for the same input.

ğŸ”· STEP 8: MASKING (CRUCIAL DETAIL)

To avoid patterns scanners hate, QR applies 8 mask patterns.

The library:

Tries all masks

Calculates penalty score

Chooses best one

ğŸ“Œ This step ensures:

No large blank areas

Better scan reliability

ğŸ”· STEP 9: RENDERING (FINAL STEP)

Only now does the QR become an image.

QRCode.js:

Converts matrix â†’ <canvas> or <img>

Encodes image as Base64

Inserts it into #qrBox

This is what you finally see.

ğŸ”· WHY SAME INPUT = SAME QR ALWAYS

Because:

Encoding rules are fixed

Binary conversion is deterministic

Error correction is deterministic

Mask selection follows rules

So:

"send" â†’ same bits â†’ same matrix â†’ same QR


ğŸ“Œ Thatâ€™s why your database check works perfectly.

ğŸ”· HOW YOUR â€œDATABASEâ€ FITS INTO THIS

Your logic does:

if (qrDatabase[text])


Meaning:

If QR already generated â†’ reuse stored Base64

If not â†’ generate once and store

This is called:

Client-side caching of deterministic outputs

Used everywhere:

Browsers

APIs

CDNs

QR payment systems

ğŸ”· HOW SCANNERS READ IT BACK

Scanner reverses the process:

Image
 â†“
Matrix
 â†“
Error correction
 â†“
Binary
 â†“
Text


Thatâ€™s why QR is lossless.